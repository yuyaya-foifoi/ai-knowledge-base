- 🟥 Host（ホスト）
何か？
ClaudeのようなLLMアプリケーションそのもの。

役割：
MCPを使ってデータや機能にアクセスしたい側。

例： Claude, AIエージェント, IDEなど。

🟥 MCP Client（MCPクライアント）
何か？
ホストアプリの中に組み込まれたMCPサーバーと通信するためのクライアントモジュール。

役割：
MCP Serverと1対1で接続して、機能呼び出しやデータ取得を行う。

🟥 MCP Protocol（MCPプロトコル）
何か？
クライアントとサーバー間でやり取りされる標準化された通信ルール・仕様。

役割：
通信の共通語。異なるアプリやサービス間でも連携できるのはこのおかげ。

🟥 MCP Server（MCPサーバー）
何か？
何かしらのサービス（例：Google DriveやNotionなど）をMCP経由で利用できるようにする軽量なプログラム。

役割：
外部サービスの機能を「ツール＋スキーマ」として定義し、MCP経由で提供。

🧠 一言でまとめると
LLMアプリ（Host）は、MCP Clientを通じて、標準プロトコルでMCP Serverにアクセスすることで、外部のデータや機能を簡単に扱えるようになる仕組み。

🏗️ イメージで例えるなら：
役割	たとえ
Host	スマホアプリ
MCP Client	スマホの通信モジュール
MCP Protocol	インターネットの通信ルール（例：HTTP）
MCP Server	GoogleやSlackなどのサーバーAPI

- 
✅ MCP Client と MCP Server の関係
役割	MCP Client	MCP Server
誰が使う？	LLMアプリ（Claudeなど）が持つ	データや機能を提供する側
主な動作	ツールを呼び出す（Invoke）
リソースを参照する（Query）
プロンプトを補完する（Interpolate）	ツール・リソース・プロンプトテンプレートを提供（Expose）
例えると	レストランの注文客	レストランのキッチン（提供者）

✅ 下段の「3要素」の違い（図の下にあるボックス）
要素	説明	例	クライアントでの使われ方
🧰 Tools	クライアントが呼び出せる「機能」	例：検索、メッセージ送信、DB更新	呼び出して何かアクションをする
📂 Resources	サーバーが提供する「読み取り専用データ」	例：ファイル、DBレコード、API結果	データを参照するために問い合わせる
🧾 Prompt Templates	あらかじめ定義されたプロンプト文	例：要約、Q&A、JSON形式出力	入力文を補完・構築するために使う

🔁 全体の流れをまとめると：
MCP Server が「ツール・リソース・プロンプトテンプレート」を公開

MCP Client（＝LLMアプリ内の一部）がそれらを使ってAIを賢く動かす

Client は：

ツールを呼び出してアクションを起こし、

リソースを読んで情報を取得し、

プロンプトテンプレートを使って自然言語を構成する

🧠 超ざっくり言うと：
MCP Clientは「使う側」、MCP Serverは「提供する側」
Serverは「機能（Tools）」「データ（Resources）」「指示テンプレ（Prompt Templates）」を提供する

　- このスライドは、**MCPにおける「Resources（リソース）」の仕組みと実装方法**を説明しています。
簡単に言うと：

> \*\*MCP Server がクライアントに「データ」を提供する方法（＝Resource）\*\*を示しており、その定義方法をコード付きで紹介しています。

---

## 🧱 基本の考え方

### ✅ MCPの「Resource」とは？

* **MCP Client がアクセスできる読み取り専用のデータ**（例：ファイル名一覧、特定ファイルの中身など）
* 通常のWebアプリでいう `GET API` に近い
* データ形式は自由（文字列、JSON、バイナリなど）

---

## 🧩 構成要素の説明（左側）

| 項目                                | 内容                                    |
| --------------------------------- | ------------------------------------- |
| `Expose data to the client`       | MCPサーバーがクライアントにデータ提供する機能              |
| `Similar to GET request handlers` | 通常のHTTPサーバーでいうGETエンドポイント              |
| `Return any type of data`         | JSONでもテキストでも画像でもOK（`mime_type`で指定）    |
| `Two types: direct and templated` | 直接URI指定する方法と、テンプレート（パラメータ付き）で動的指定する方法 |

---

## 🔧 実装例（右側）

### ① **Direct Resource**（固定URI）

```python
@mcp.resource(
  "docs://documents",
  mime_type="application/json"
)
def list_docs():
    # Return a list of document names
```

* `/documents` という固定URIにアクセスしたときに
* JSON形式でドキュメント名の一覧を返す

---

### ② **Templated Resource**（可変URI）

```python
@mcp.resource(
  "docs://documents/{doc_id}",
  mime_type="text/plain"
)
def fetch_doc(doc_id: str):
    # Return the contents of a doc
```

* `doc_id` を引数にとって、`/documents/abc123` みたいにアクセス
* 対象ドキュメントの中身を返す（テキスト）

---

## 🧠 まとめると

> MCPにおける「Resource」は、**LLMから安全かつ標準的にデータを引き出すための仕組み**。
> しかも、Web APIと同じ感覚で簡単に定義できるようになっている。

# 
この図は、**MCP Serverが提供する2種類のResource（データ参照）方法**を、LLMの使い方視点で分かりやすく説明しています。

---

## 🧠 言いたいこと（まとめ）

> MCP Serverは、
>
> * 複数ファイル一覧を返す（**Direct Resource**）
> * 特定ファイルの中身を返す（**Templated Resource**）
>   の2種類の方法で、LLMにデータを提供できる。

---

## 🔍 上半分：**Direct Resources（一覧取得）**

* **ユーザーの入力例**：
  `Can you please summarize the contents of @...`

* **MCP Serverの役割**：
  クライアントに**すべての利用可能なファイル名（例：`design.md`, `plan.md`）の一覧を返す**

* **目的**：
  **どのファイルがあるのかをLLMが知るための入り口**
  たとえば「どのファイルを要約したいのか選ばせる」ときに使う

---

## 🔍 下半分：**Templated Resources（単一ドキュメント取得）**

* **ユーザーの入力例**：
  `What's in the @report.pdf file?`

* **MCP Serverの役割**：
  特定ファイル（`report.pdf`）の**内容そのものを返す**

* **目的**：
  **ユーザーが参照したドキュメントの中身を取り出して、LLMに渡して処理させる**

---

## 🔁 Direct vs Templated 比較表

| 種類                     | 目的             | 例                          | MCPが返すもの                                   |
| ---------------------- | -------------- | -------------------------- | ------------------------------------------ |
| **Direct Resource**    | 利用可能なリソースの一覧取得 | `list_docs()`              | `["a.md", "b.pdf", "c.json"]`              |
| **Templated Resource** | 特定のリソースの中身取得   | `fetch_doc(doc_id="a.md")` | `"# Chapter 1\nThis document is about..."` |

---

## 📌 一言で言うと

> **Direct** は「なにがあるかを一覧で知る」
> **Templated** は「これを見たい！というときに中身を取る」

---

もしプロンプトテンプレートとの組み合わせ方や、実際のユースケース（例：社内ナレッジ検索など）に興味があれば、さらに解説できます！


この2枚のスライドは、**MCPにおける「Prompt Templates（プロンプトテンプレート）」の重要性と活用方法**を説明しています。

---

## 🔧 1枚目：MCPでのプロンプトの定義方法（実装）

### 🧩 左側：基本説明

* **Promptとは？**

  * ユーザーとアシスタントのやり取りのテンプレート
  * クライアント（LLM）がそれを使って、一貫性のある応答を生成できる
* **ポイント：** 高品質かつよくテストされたものであるべき

### 🧩 右側：コード例

```python
@mcp.prompt(
  name="format",
  description="Rewrites the contents of a document in Markdown format"
)
def format_document(doc_id: str) -> list[base.Message]:
    # Return a list of messages
```

* `@mcp.prompt` でプロンプトテンプレートを定義
* `doc_id` を受け取り、Markdown形式への変換指示などを含む\*\*一連のメッセージリスト（User/Assistant）\*\*を返す

---

## 💡 2枚目：なぜ良いプロンプトテンプレが必要なのか

### 🔻 左側：ユーザーに任せると…

```plaintext
Convert report.pdf to markdown
```

* シンプルで使えそうではあるが、指示が**曖昧で品質が安定しない**

---

### 🔺 右側：よく設計されたプロンプトテンプレートを使うと…

```plaintext
You are a document conversion specialist...
<document_id>{doc_id}</document_id>
Instructions:
1. Retrieve the content...
2. Analyze structure...
3. Use #, ## for headers...
...
```

* より具体的な文脈・ルール・出力形式が**厳密に定義**されている
* LLMの挙動が安定し、**信頼性の高い変換結果が得られる**

---

## ✅ まとめ

| 比較軸   | ユーザーが書いたプロンプト | MCPのPromptテンプレート      |
| ----- | ------------- | --------------------- |
| 精度    | ばらつきがある       | 安定・一貫性がある             |
| 導入コスト | 低いが品質に依存      | 高品質を一度定義すれば何度でも再利用可能  |
| 利用シーン | 単発のタスク        | プロダクション・AIアプリ・エージェント系 |

---

## 🧠 一言で言うと：

> **プロンプトテンプレートは、LLMを“精度高く・一貫して”動かすための設計図**。
> MCPではこれを「関数」として定義でき、どのクライアントからも再利用できる。

---

- 
この2枚のスライドは、\*\*MCPにおける通信の流れ（通信ライフサイクル）と、通信方法（トランスポート層）\*\*について説明しています。

---

## 🧭 1枚目：「Communication Lifecycle」＝ MCP通信の3段階

MCP Client（例：LLMアプリ）と MCP Server（例：データ提供側）が**どう接続・やりとり・終了するか**を時系列で説明しています。

### ① Initialization（初期化）

* クライアントが「接続開始リクエスト」を送信
* サーバーが「OK」と応答
* 「初期化完了」の通知がクライアントに届く
  → **接続が確立される**

### ② Message Exchange（メッセージ交換）

* クライアントが**リクエストを送信**
* サーバーが**レスポンスを返す**
  → これを繰り返すことで、プロンプト処理やデータ取得が行われる

### ③ Termination（終了）

* 最終的に通信が終了し、接続をクローズする

---

## 🧱 2枚目：「MCP Transports」＝ メッセージを**どうやって送受信するか**

これは「クライアントとサーバーの**通信プロトコルの選択肢**」を表しています。

### 通信方法の種類：

#### ✅ 1. **ローカル実行時（同じマシン内）**

* `stdio`（標準入出力）
  → ターミナルなどで起動してやり取り

#### ✅ 2. **リモートサーバーと通信する場合**

| 種類                  | 内容                                        |
| ------------------- | ----------------------------------------- |
| **HTTP + SSE**      | サーバーからクライアントへ一方向にデータを送る方式（2024年11月からサポート） |
| **Streamable HTTP** | 双方向にストリーム形式でやり取りできる進化版（2025年3月からサポート）     |

---

## 🧠 一言でまとめると：

> 「MCPではクライアントとサーバーが ①接続 → ②メッセージ交換 → ③終了 という手順でやり取りを行い、
> その通信方式は `stdio`, `HTTP+SSE`, `Streamable HTTP` から選べる」

---

通信プロトコルごとのメリット（例えばストリーミング対応によるUX向上）や、どれを選ぶべきかといった話も気になるようでしたら、さらに詳しく説明します！


これら2枚のスライドは、\*\*MCPにおける通信手段（Transport）\*\*の違いを説明しています。
言い換えると「**MCP ClientとServerがどうやってデータをやり取りするかの経路・方式の種類**」を解説しています。

---

## 🧱 スライド1：ローカル通信 — `Standard IO (stdio)` Transport

### 🔸 どういうときに使う？

* サーバーを**ローカルPC内**で動かすとき
* 開発・デバッグ・テスト時によく使われる

### 🔁 通信の仕組み

| 処理                          | 説明                                   |
| --------------------------- | ------------------------------------ |
| クライアントがサーバーを**サブプロセスとして起動** | Pythonなどで `subprocess.Popen()` のような形 |
| サーバーの `stdin` に書き込み         | クライアント → サーバーへのリクエスト送信               |
| サーバーの `stdout` を読み取り        | サーバー → クライアントへのレスポンス受信               |
| 通信が終わったら `stdin` を閉じる       | 接続終了・プロセス停止                          |

### ✅ 特徴まとめ

* シンプルで軽い
* ネットワーク不要（同一マシン内）
* プロトタイプやローカル環境で便利

---

## 🌐 スライド2：リモート通信 — `HTTP + SSE` と `Streamable HTTP`

### 🧩 左：HTTP + SSE（2024年11月～）

| 項目     | 内容                                              |
| ------ | ----------------------------------------------- |
| 通信方式   | HTTPでリクエスト、SSE（Server Sent Events）でストリーミング応答    |
| 接続形態   | **状態を保持する通信**（stateful）                         |
| 特徴     | クライアントがPOST → サーバーが継続的にデータを送り返す（例：段階的にLLM応答を返す） |
| ユースケース | チャットボット、ログストリーム、ドキュメント逐次生成                      |

---

### 🧩 右：Streamable HTTP（2025年3月～）

| 項目     | 内容                                  |
| ------ | ----------------------------------- |
| 通信方式   | POST + ストリーム可能なHTTP（通常のHTTP or SSE） |
| 接続形態   | **ステートフルでもステートレスでもOK**              |
| 特徴     | より柔軟。長時間処理や部分応答に適している。双方向通信にも拡張しやすい |
| ユースケース | LLMによる推論（途中結果表示）、ファイル変換の進捗など        |

---

## 🚦 まとめ：どれを使うべき？

| シーン         | 推奨Transport       | 理由                 |
| ----------- | ----------------- | ------------------ |
| 開発中 or ローカル | `stdio`           | 設定不要、超軽量、すぐ動かせる    |
| シンプルなリモート接続 | `HTTP + SSE`      | 一方向ストリーミングが欲しいなら十分 |
| 複雑・柔軟な通信が必要 | `Streamable HTTP` | 長時間・部分応答・双方向などに対応  |

---

## 💬 一言でまとめると：

> MCPは**用途に応じて3つの通信手段を選べる**。
> ローカルなら`stdio`、リモートなら`SSE`か`Streamable HTTP`。
> LLMとのやり取りにはストリーミング対応が特に重要！

---

もし実際の実装方法やPythonでのサンプルコードが必要なら、それも対応できます！


この図は、**Streamable HTTP Transport** におけるMCPクライアントとサーバーの通信の\*\*詳細な流れ（ライフサイクル）\*\*を時系列で示しています。

---

## 🧭 図の全体像

これは「\*\*状態を持つセッション的なやりとり（Stateful）\*\*をStreamable HTTPでどう実現するか？」を説明しています。下から上に進む順で説明します。

---

## 🔁 通信ステップごとの説明

---

### ✅ **1. POST /mcp to initialize request**

（セッション初期化のためのPOST）

* **誰が？**：MCPクライアント（Claudeなど）
* **何を？**：セッション開始のための初回リクエストをPOSTで送る
* **例**：

  ```http
  POST /mcp
  {
    "init_type": "document_summary",
    "doc_id": "report.pdf"
  }
  ```

---

### ✅ **2. Initialize response**

* **誰が？**：MCPサーバー
* **何を？**：そのセッションに関する初期設定のレスポンス（例：セッションID、利用可能なリソースなど）
* → ここでセッションが仮に「stateful」になる

---

### 🔁 **（オプション）3. GET /mcp with Accept: text/event-stream**

* **これは？**：クライアントが**SSE（Server Sent Events）による応答ストリームの準備**をリクエストする
* **役割**：

  * クライアントが「ずっと接続を開いたまま、サーバーからのデータを待つ」
  * サーバーが随時「partial result」や「最終結果」を送れる

---

### ✉️ **4. Server can now send messages to client**

* **何が起こる？**：サーバーは、SSEストリーム経由でメッセージを小分けにして送れる

  * 部分的な回答（LLMのトークン）
  * ログ
  * 進捗情報

---

### 🔁 **5. POST /mcp with request**

* **セッション中の追加リクエスト**：

  * たとえば「次のファイルも要約して」「補足説明して」など
  * すでに初期化されているので、前の文脈に基づいた処理が可能（＝stateful）

---

### 🔚 **（オプション）6. DELETE /mcp to terminate session**

* 明示的にセッションを終了したいとき
* サーバー側がセッションデータ（キャッシュや一時保存など）を削除できる

---

### ✅ **7. Session terminated**

* クライアント側が切断 or サーバー側が自動的にタイムアウト
* メモリや一時ファイル、セッションIDなどをクリーンアップ

---

## 🧠 つまりどういうこと？

> Streamable HTTPでは、**POSTで開始 →（必要に応じて）SSEで継続的に受信 → 必要に応じて明示的に終了**という形で、**一連のセッションフローをHTTPベースで構成できる**というのが特徴です。

---

## ✅ 特徴まとめ

| 項目   | 内容                            |
| ---- | ----------------------------- |
| 状態管理 | セッションとして状態を持てる（＝stateful）     |
| 通信方式 | HTTP POST + SSE（または通常のHTTP応答） |
| 柔軟性  | オプションのSSEでストリーミングにも対応         |
| 利用例  | LLMチャット、長文変換、ログストリームなど        |

---

さらに実装レベル（エンドポイントの設計、状態の保持、セキュリティトークン管理など）に踏み込みたい場合は、そちらも解説できますよ。興味ありますか？
